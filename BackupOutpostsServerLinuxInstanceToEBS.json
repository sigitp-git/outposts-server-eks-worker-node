{
  "description": "This automation runbook creates an EBS-backed AMI in region storing the data of the instance store root volume of the Linux instance running on Outposts Server. The automation uses a helper instance in Region to replicate the partitioning and content of the mounted file systems from the instance store root volume to an EBS volume restored from a previous Backup (passing an AMI ID as input parameter). If no AMI ID is specified, the automation searches for any previous backup and it takes the most recent one created with this automation. If no backup is found (e.g. when doing the first backup), the automation uses the base AMI from which the instance was launched.",
  "schemaVersion": "0.3",
  "assumeRole": "{{ AssumeRole }}",
  "parameters": {
    "InstanceId": {
      "type": "AWS::EC2::Instance::Id",
      "description": "(Required) ID of the EC2 instance running on Outposts Server that you want to backup."
    },
    "AmiId": {
      "type": "String",
      "description": "(Required) ID of the AMI from a previous backup to use as a baseline for the incremental backup. If you leave the default SelectAutomatically option, the Document will search for any previous backup and it will take the most recent one created with this Automation. If this is the first backup or no previous backup is found (e.g. because the previous backups were deleted), the Document will use the base AMI from which the instance was launched",
      "default": "SelectAutomatically",
      "allowedPattern": "^SelectAutomatically$|^ami-[a-f0-9]{17}$"
    },
    "SubnetId": {
      "type": "String",
      "description": "(Required) The subnet ID in Region to create the helper instance. IMPORTANT: The Outposts Server instance will need to communicate with the helper instance using its private IP and the SSH port, so you must specify a subnet whose private CIDR is reachable from the Outposts Server instance (e.g. a Subnet in region in the same VPC of the Outposts Server).",
      "allowedPattern": "^subnet-[a-f0-9]{8}$|^subnet-[a-f0-9]{17}$"
    },
    "TemporaryInstancesType": {
      "type": "String",
      "default": "c5.large",
      "description": "(Required) The EC2 instance type of the helper and baseline instances. The CPU arch of the selected instance type must be the same of the instance to backup (e.g. specify Graviton instance type if your Outposts Server instance is running on 1U server). Xen instance types are not Supported.",
      "allowedPattern": "^((c5|c5a|c5ad|c5d|c5n|c6a|c6g|c6gd|c6gn|c6i|c6id|c7g|c7gn|g4ad|g4dn|g5|g5g|i3en|i4i|im4gn|inf1|is4gen|m5|m5a|m5ad|m5d|m5dn|m5n|m5zn|m6a|m6g|m6gd|m6i|m6id|m7g|p3dn|p4d|r5|r5a|r5ad|r5b|r5d|r5dn|r5n|r6a|r6g|r6gd|r6i|r6id|r7g|t3|t3a|t4g|trn1|u-12tb1|u-3tb1|u-6tb1|u-9tb1|vt1|x2gd|x2idn|x2iedn|x2iezn|z1d)\\.(10xlarge|112xlarge|12xlarge|16xlarge|18xlarge|24xlarge|2xlarge|32xlarge|3xlarge|48xlarge|4xlarge|56xlarge|6xlarge|8xlarge|9xlarge|large|medium|metal|micro|nano|small|xlarge))$"
    },
    "MaxThroughput": {
      "type": "String",
      "description": "(Optional) the maximum throughput in MiB/s allowed for the data sync.  Leave 0 (default option) if you do not want to set a limitation",
      "default": "0",
      "allowedPattern": "^[0-9]{1,10}$"
    },
    "Exclusions": {
      "type": "String",
      "description": "(Optional) the list of space-separated file and/or directory names, paths or patterns matching the files/directories/paths that you want to exclude from the backup. e.g. /data/ephemeral *.swp /data/temporarycache dummyfile. Leave empty if you do not want to exclude anything from the backup.",
      "default": "",
      "allowedPattern": "^.{0,1024}$"
    },
    "UniqueId": {
      "type": "String",
      "description": "(Required) A unique identifier for the workflow.",
      "default": "{{ automation:EXECUTION_ID }}",
      "allowedPattern": "\\{\\{ automation:EXECUTION_ID \\}\\}|^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$"
    },
    "AssumeRole": {
      "type": "AWS::IAM::Role::Arn",
      "description": "(Optional) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf. If no role is specified, Systems Manager Automation uses the permissions of the user that starts this runbook. For more information, visit - https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-setup.html"
    }
  },
  "files": {
    "attachment.zip": {
      "checksums": {
        "sha256": "8b3fc69ba8229f450af1f6ae69a82b38129fd1b4de2cb93233b89a19af4b9481"
      }
    }
  },
  "mainSteps": [
    {
      "description": "Ensures there is only one execution of this runbook targeting the provided EC2 instance. ",
      "name": "ensureNoConcurrentExecutionsForTargetInstance",
      "action": "aws:executeScript",
      "maxAttempts": 3,
      "nextStep": "assertInstanceStatus",
      "isCritical": true,
      "isEnd": false,
      "onFailure": "Abort",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "checkConcurrency.check_concurrency_handler",
        "InputPayload": {
          "InstanceId": "{{ InstanceId }}"
        },
        "Attachment": "attachment.zip"
      }
    },
    {
      "description": "Make sure the Outposts Server instance is in 'running' state.",
      "name": "assertInstanceStatus",
      "action": "aws:assertAwsResourceProperty",
      "nextStep": "assertEC2OutpostsServerInstanceConnectedwithSSM",
      "isCritical": true,
      "isEnd": false,
      "onFailure": "Abort",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeInstances",
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "PropertySelector": "Reservations[0].Instances[0].State.Name",
        "DesiredValues": [
          "running"
        ]
      }
    },
    {
      "description": "Make sure the Outposts Server instance is a SSM managed instance.",
      "name": "assertEC2OutpostsServerInstanceConnectedwithSSM",
      "action": "aws:assertAwsResourceProperty",
      "nextStep": "assertInstancePlatformIsLinux",
      "isCritical": true,
      "isEnd": false,
      "onFailure": "Abort",
      "inputs": {
        "Service": "ssm",
        "Api": "DescribeInstanceInformation",
        "InstanceInformationFilterList": [
          {
            "key": "InstanceIds",
            "valueSet": [
              "{{ InstanceId }}"
            ]
          }
        ],
        "PropertySelector": "$.InstanceInformationList[0].PingStatus",
        "DesiredValues": [
          "Online"
        ]
      }
    },
    {
      "description": "Checks the provided Instance's platform is Linux.",
      "name": "assertInstancePlatformIsLinux",
      "action": "aws:assertAwsResourceProperty",
      "nextStep": "describeInstance",
      "isCritical": true,
      "isEnd": false,
      "onFailure": "Abort",
      "inputs": {
        "Service": "ssm",
        "Api": "DescribeInstanceInformation",
        "Filters": [
          {
            "Key": "InstanceIds",
            "Values": [
              "{{ InstanceId }}"
            ]
          }
        ],
        "PropertySelector": "$.InstanceInformationList[0].PlatformType",
        "DesiredValues": [
          "Linux"
        ]
      }
    },
    {
      "description": "Describes the provided instance.",
      "name": "describeInstance",
      "action": "aws:executeAwsApi",
      "nextStep": "assertInstanceRootVolumeIsInstanceStore",
      "isCritical": true,
      "isEnd": false,
      "onFailure": "Abort",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeInstances",
        "InstanceIds": [
          "{{ InstanceId }}"
        ]
      },
      "outputs": [
        {
          "Name": "RootDeviceName",
          "Selector": "$.Reservations[0].Instances[0].RootDeviceName",
          "Type": "String"
        },
        {
          "Name": "Architecture",
          "Selector": "$.Reservations[0].Instances[0].Architecture",
          "Type": "String"
        },
        {
          "Name": "State",
          "Selector": "$.Reservations[0].Instances[0].State.Name",
          "Type": "String"
        },
        {
          "Name": "SubnetId",
          "Selector": "$.Reservations[0].Instances[0].NetworkInterfaces[0].SubnetId",
          "Type": "String"
        },
        {
          "Name": "AvailabilityZone",
          "Selector": "$.Reservations[0].Instances[0].Placement.AvailabilityZone",
          "Type": "String"
        },
        {
          "Name": "VpcId",
          "Selector": "$.Reservations[0].Instances[0].NetworkInterfaces[0].VpcId",
          "Type": "String"
        },
        {
          "Name": "InstanceType",
          "Selector": "$.Reservations[0].Instances[0].InstanceType",
          "Type": "String"
        },
        {
          "Name": "VirtualizationType",
          "Selector": "$.Reservations[0].Instances[0].VirtualizationType",
          "Type": "String"
        }
      ]
    },
    {
      "description": "Checks the root volume device type is instance-store.",
      "name": "assertInstanceRootVolumeIsInstanceStore",
      "action": "aws:assertAwsResourceProperty",
      "nextStep": "checkOSRequirements",
      "isCritical": true,
      "isEnd": false,
      "onFailure": "Abort",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeInstances",
        "InstanceIds": [
          "{{ InstanceId }}"
        ],
        "PropertySelector": "$.Reservations[0].Instances[0].RootDeviceType",
        "DesiredValues": [
          "instance-store"
        ]
      }
    },
    {
      "description": "Checks the OS software requirements before starting",
      "name": "checkOSRequirements",
      "action": "aws:runCommand",
      "nextStep": "getAZfromSubnetParameter",
      "isCritical": "true",
      "isEnd": false,
      "onFailure": "Abort",
      "inputs": {
        "DocumentName": "AWS-RunShellScript",
        "InstanceIds": [
          "{{InstanceId}}"
        ],
        "Parameters": {
          "commands": [
            "#!/bin/bash",
            "",
            "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.",
            "# SPDX-License-Identifier: MIT-0",
            "",
            "error_trap()",
            "{",
            "    if test -n \"$1\" ; then",
            "        printf \"%s\\\\n\" \"[ERROR] $1\"",
            "    fi",
            "",
            "    printf \"%.s=\" $(seq 1 80)",
            "    printf \"\\\\nThe checkOSRequirements Script execution did not complete successfully.\\\\n\"",
            "",
            "    exit 1",
            "}",
            "compare_versions()",
            "{",
            "        # function to compare a program version with a supported one and throw an error if lower.",
            "        program_ver=\"$1\"",
            "        supported_ver=\"$2\"",
            "        if [ \"$(printf \"%s\\n\" \"${supported_ver}\" \"${program_ver}\" | sort -V | head -n1)\" = \"${supported_ver}\" ]; then",
            "               echo \"[INFO] OK - program version ${program_ver} greater than or equal to ${supported_ver}\"",
            "        else",
            "               error_trap \"FAIL - program version ${program_ver} less than ${supported_ver}\"",
            "        fi",
            "}",
            "unalias -a",
            "shopt -s expand_aliases",
            "",
            "# Check if aws cli is available in the outposts server instance",
            "aws --version > /dev/null 2>&1 || error_trap \"error in retrieving the aws cli version, please make sure aws cli is installed on the instance running on Outposts Server\"",
            "",
            "# Check if rsync is available in the outposts server instance and its version is equal or greater than the supported version",
            "rsync --version > /dev/null 2>&1 || error_trap \"error in retrieving the rsync version, please make sure rsync is installed on the instance running on Outposts Server\"",
            "RSYNC_SUPPORTED_VER=\"3.1.2\"",
            "RSYNC_SOURCE_VER=$(rsync --version | sed -n '1s/^rsync *version \\([0-9.]*\\).*$/\\1/p')",
            "echo \"[INFO] Checking if rsync version is greater or equal to \"${RSYNC_SUPPORTED_VER}\"\"",
            "compare_versions \"${RSYNC_SOURCE_VER}\" \"${RSYNC_SUPPORTED_VER}\"",
            "",
            "# Check if sfdisk is available in the outposts server instance and its version is equal or greater than the supported version",
            "sfdisk -v > /dev/null 2>&1 || error_trap \"error in retrieving the sfdisk version, please make sure sfdisk is installed on the instance running on Outposts Server\"",
            "SFDISK_SUPPORTED_VER=\"2.26\"",
            "SFDISK_SOURCE_VER=$(sfdisk -v | awk 'NR==1' | sed 's/^.*[^0-9]\\([0-9]*\\.[0-9]*\\.[0-9]*\\).*$/\\1/')",
            "echo \"[INFO] Checking if sfdisk version is greater or equal to \"${SFDISK_SUPPORTED_VER}\"\"",
            "compare_versions \"${SFDISK_SOURCE_VER}\" \"${SFDISK_SUPPORTED_VER}\"",
            "",
            "echo \"[INFO] Execution finished successfully\""
          ]
        }
      }
    },
    {
      "description": "Retrieves the AZ from the Subnet provided in the input parameters",
      "name": "getAZfromSubnetParameter",
      "action": "aws:executeAwsApi",
      "nextStep": "getDefaultRootVolumeSizeForInstanceType",
      "isCritical": true,
      "isEnd": false,
      "onFailure": "Abort",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeSubnets",
        "SubnetIds": [
          "{{ SubnetId }}"
        ]
      },
      "outputs": [
        {
          "Name": "SubnetAZ",
          "Selector": "$.Subnets[0].AvailabilityZone",
          "Type": "String"
        }
      ]
    },
    {
      "description": "Retrieves the size of the Instance store root volume from the Instance type",
      "name": "getDefaultRootVolumeSizeForInstanceType",
      "action": "aws:executeAwsApi",
      "nextStep": "getOutpostsServerSubnetCIDR",
      "isCritical": true,
      "isEnd": false,
      "onFailure": "Abort",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeInstanceTypes",
        "InstanceTypes": [
          "{{ describeInstance.InstanceType }}"
        ]
      },
      "outputs": [
        {
          "Name": "RootDeviceSize",
          "Selector": "$.InstanceTypes[0].InstanceStorageInfo.Disks[0].SizeInGB",
          "Type": "Integer"
        }
      ]
    },
    {
      "description": "get the CIDR of the Outposts Subnet. This will be used to allow the traffic from this CIDR in the SG of the Helper instance",
      "name": "getOutpostsServerSubnetCIDR",
      "action": "aws:executeAwsApi",
      "nextStep": "stageCreateHelperInstanceAutomation",
      "isCritical": true,
      "isEnd": false,
      "onFailure": "Abort",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeSubnets",
        "SubnetIds": [
          "{{describeInstance.SubnetId}}"
        ]
      },
      "outputs": [
        {
          "Name": "CidrBlock",
          "Selector": "$.Subnets[0].CidrBlock",
          "Type": "String"
        }
      ]
    },
    {
      "description": "Deploys the EC2 Helper Instance CloudFormation stack.",
      "name": "stageCreateHelperInstanceAutomation",
      "action": "aws:createStack",
      "nextStep": "waitForEC2HelperInstanceCreation",
      "isCritical": true,
      "isEnd": false,
      "onCancel": "step:unstageCreateHelperInstanceAutomation",
      "onFailure": "step:describeCloudFormationErrorFromStackEvents",
      "inputs": {
        "StackName": "BackupOutpostsServerInstance-EC2Helper-{{ UniqueId }}",
        "TemplateBody": "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n# SPDX-License-Identifier: MIT-0\n\nAWSTemplateFormatVersion: 2010-09-09\nDescription: Creates a helper instance in the specified AZ or subnet\nParameters:\n    Architecture:\n        Type: String\n        AllowedValues:\n        - arm64\n        - x86_64\n    OutpostsSubnetCIDR:\n        Description: Outposts Server Subnet CIDR.\n        Type: String\n    SubnetId:\n        Description: Subnet ID of the helper instance.\n        Type: String\n    VpcId:\n        Description: VPC ID of the helper instance and Outposts Server instance.\n        Type: String\n    KeyPairName:\n        Description: SSH KeyPair Name of the helper instance\n        Type: String\n    ExecutionId:\n        Description: Systems Manager Automation Execution ID.\n        Type: String\n        Default: ''\n    HelperInstanceLinuxAMI:\n        Description: Helper instance AMI ID.\n        Type: 'AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>'\n        Default: /aws/service/ami-amazon-linux-latest/al2023-ami-kernel-default-x86_64\n    HelperInstanceARMLinuxAMI:\n        Description: Helper instance AMI ID.\n        Type: 'AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>'\n        Default: /aws/service/ami-amazon-linux-latest/al2023-ami-kernel-default-arm64\n    HelperInstanceType:\n        Description: The EC2 instance type for the EC2 Helper instance.\n        Type: String\n    CreateHelperInstance:\n        Description: 'Confirm that you want to create the helper instance. Default: False'\n        Type: String\n        Default: 'False'\n        AllowedValues:\n        - 'True'\n        - 'False'\nConditions:\n    ArchitectureIsARM: !Equals \n        - !Ref Architecture\n        - arm64\n    CreateHelperInstance: !Equals \n        - !Ref CreateHelperInstance\n        - 'True'\nResources:\n    IsolatedSecurityGroup:\n        Type: AWS::EC2::SecurityGroup\n        Properties:\n            GroupDescription: Block the outbound connectivity\n            VpcId: !Ref VpcId\n            SecurityGroupEgress:\n              - CidrIp: 127.0.0.1/32\n                IpProtocol: -1\n    HelperInstanceSecurityGroup:\n        Type: AWS::EC2::SecurityGroup\n        Properties:\n            GroupDescription: Allow SSH connection from the Outposts Server subnet CIDR\n            VpcId: !Ref VpcId\n            SecurityGroupIngress:\n              - IpProtocol: tcp\n                FromPort: 22\n                ToPort: 22\n                CidrIp: !Ref OutpostsSubnetCIDR\n    HelperInstanceKeyPair:\n        Type: 'AWS::EC2::KeyPair'\n        Properties:\n            KeyName: !Ref KeyPairName\n    HelperEc2InstanceLaunchTemplate:\n        Type: AWS::EC2::LaunchTemplate\n        Properties:\n            LaunchTemplateData:\n                MetadataOptions:\n                    HttpEndpoint: enabled\n                    HttpTokens: required\n    HelperInstance:\n        Condition: CreateHelperInstance\n        Type: 'AWS::EC2::Instance'\n        Properties:\n            ImageId: !If\n                    - ArchitectureIsARM\n                    - !Ref HelperInstanceARMLinuxAMI\n                    - !Ref HelperInstanceLinuxAMI\n            KeyName: !Ref HelperInstanceKeyPair\n            LaunchTemplate:\n                LaunchTemplateId: !Ref HelperEc2InstanceLaunchTemplate\n                Version: !GetAtt HelperEc2InstanceLaunchTemplate.LatestVersionNumber\n            InstanceType: !Ref HelperInstanceType\n            PropagateTagsToVolumeOnCreation: true\n            NetworkInterfaces:\n              - AssociatePublicIpAddress: true\n                DeleteOnTermination: true\n                DeviceIndex: '0'\n                SubnetId: !Ref SubnetId\n                GroupSet:\n                  - !Ref HelperInstanceSecurityGroup\n            UserData:\n                Fn::Base64: !Sub |\n                    #!/bin/bash\n                    grubby --update-kernel ALL --args selinux=0\n                    reboot\nOutputs:\n    HelperInstanceId:\n        Value: !Ref HelperInstance\n    HelperInstancePrivateIp:\n        Value: !GetAtt HelperInstance.PrivateIp\n    HelperInstanceKeyID:\n        Value: !GetAtt HelperInstanceKeyPair.KeyPairId\n    IsolatedSgId:\n        Value: !Ref IsolatedSecurityGroup\n",
        "Capabilities": [
          "CAPABILITY_NAMED_IAM"
        ],
        "ClientRequestToken": "BackupOutpostsServerInstance-EC2Helper-{{ UniqueId }}",
        "Parameters": [
          {
            "ParameterKey": "CreateHelperInstance",
            "ParameterValue": "True"
          },
          {
            "ParameterKey": "Architecture",
            "ParameterValue": "{{ describeInstance.Architecture }}"
          },
          {
            "ParameterKey": "SubnetId",
            "ParameterValue": "{{ SubnetId }}"
          },
          {
            "ParameterKey": "VpcId",
            "ParameterValue": "{{ describeInstance.VpcId }}"
          },
          {
            "ParameterKey": "OutpostsSubnetCIDR",
            "ParameterValue": "{{ getOutpostsServerSubnetCIDR.CidrBlock }}"
          },
          {
            "ParameterKey": "KeyPairName",
            "ParameterValue": "SSMAutomation-BackupOutpostsServerInstance-{{UniqueId}}-helperInstanceKey"
          },
          {
            "ParameterKey": "HelperInstanceType",
            "ParameterValue": "{{ TemporaryInstancesType }}"
          },
          {
            "ParameterKey": "ExecutionId",
            "ParameterValue": "{{ UniqueId }}"
          }
        ],
        "Tags": [
          {
            "Key": "Name",
            "Value": "BackupOutpostsServerInstance-HelperInstance: {{ InstanceId }}"
          },
          {
            "Key": "BackupOutpostsServerInstance-HelperInstance-AutomationExecution",
            "Value": "{{ UniqueId }}"
          }
        ]
      },
      "outputs": [
        {
          "Name": "CloudFormationStackId",
          "Selector": "$.StackId",
          "Type": "String"
        }
      ]
    },
    {
      "description": "Waits for the EC2 Helper CloudFormation stack update to complete.",
      "name": "waitForEC2HelperInstanceCreation",
      "action": "aws:waitForAwsResourceProperty",
      "maxAttempts": 5,
      "timeoutSeconds": 600,
      "nextStep": "describeStackOutput",
      "isCritical": true,
      "isEnd": false,
      "onCancel": "step:unstageCreateHelperInstanceAutomation",
      "onFailure": "step:describeCloudFormationErrorFromStackEvents",
      "inputs": {
        "Service": "cloudformation",
        "Api": "DescribeStacks",
        "StackName": "{{ stageCreateHelperInstanceAutomation.CloudFormationStackId }}",
        "PropertySelector": "$.Stacks[0].StackStatus",
        "DesiredValues": [
          "UPDATE_COMPLETE",
          "CREATE_COMPLETE"
        ]
      }
    },
    {
      "description": "Describes the EC2Helper CloudFormation stack Output to obtain the id of the helper instance, its private IP, its SSH key ID and the security group id to isolate the Baseline instance.",
      "name": "describeStackOutput",
      "action": "aws:executeAwsApi",
      "nextStep": "createBaselineVolume",
      "isCritical": true,
      "isEnd": false,
      "onCancel": "step:unstageCreateHelperInstanceAutomation",
      "onFailure": "step:unstageCreateHelperInstanceAutomation",
      "inputs": {
        "Service": "cloudformation",
        "Api": "DescribeStacks",
        "StackName": "{{ stageCreateHelperInstanceAutomation.CloudFormationStackId }}"
      },
      "outputs": [
        {
          "Name": "HelperInstanceId",
          "Selector": "$.Stacks[0].Outputs[?(@.OutputKey == 'HelperInstanceId')].OutputValue",
          "Type": "String"
        },
        {
          "Name": "HelperInstancePrivateIp",
          "Selector": "$.Stacks[0].Outputs[?(@.OutputKey == 'HelperInstancePrivateIp')].OutputValue",
          "Type": "String"
        },
        {
          "Name": "HelperInstanceKeyID",
          "Selector": "$.Stacks[0].Outputs[?(@.OutputKey == 'HelperInstanceKeyID')].OutputValue",
          "Type": "String"
        },
        {
          "Name": "IsolatedSgId",
          "Selector": "$.Stacks[0].Outputs[?(@.OutputKey == 'IsolatedSgId')].OutputValue",
          "Type": "String"
        }
      ]
    },
    {
      "description": "Creates the Baseline Volume used to sync the data of the Outpost Server instance. If an AMI-ID is provided in the input parameter, this volume is created from the snapshot of the root device of that AMI. If the default automatic selection is used, this step will create a volume from the most recent backup performed. If this is the first backup this step will use the source AMI of the Outpost Server instance. If the snapshots of the Baseline AMI are not directly accessible, this step will create a Baseline instance from the AMI first and then terminate it immediately, preserving the volume that will be used as the Baseline volume.",
      "name": "createBaselineVolume",
      "action": "aws:executeScript",
      "maxAttempts": 1,
      "nextStep": "describeImage",
      "isCritical": true,
      "isEnd": false,
      "onCancel": "step:unstageCreateHelperInstanceAutomation",
      "onFailure": "step:unstageCreateHelperInstanceAutomation",
      "inputs": {
        "Runtime": "python3.8",
        "Handler": "createBaselineVolume.create_baseline_volume_handler",
        "InputPayload": {
          "InstanceId": "{{ InstanceId }}",
          "SecurityGroupId": "{{ describeStackOutput.IsolatedSgId }}",
          "AmiId": "{{ AmiId }}",
          "InstanceType": "{{TemporaryInstancesType}}",
          "SubnetId": "{{SubnetId}}",
          "VolumeAZ": "{{getAZfromSubnetParameter.SubnetAZ}}",
          "VolumeSize": "{{getDefaultRootVolumeSizeForInstanceType.RootDeviceSize}}",
          "DeviceMapping": "{{describeInstance.RootDeviceName}}"
        },
        "Attachment": "attachment.zip"
      },
      "outputs": [
        {
          "Name": "Payload",
          "Selector": "$.Payload",
          "Type": "StringMap"
        },
        {
          "Name": "BaselineVolumeId",
          "Selector": "$.Payload.baselineVolumeId",
          "Type": "String"
        },
        {
          "Name": "BaselineAmiId",
          "Selector": "$.Payload.baselineAmiId",
          "Type": "String"
        },
        {
          "Name": "VolumeSizeGiB",
          "Selector": "$.Payload.volumeSizeGiB",
          "Type": "Integer"
        }
      ]
    },
    {
      "description": "Describes the ImageId of the BaselineInstance and check if it has markeplace product code associated to it.",
      "name": "describeImage",
      "action": "aws:executeAwsApi",
      "nextStep": "branchOnMarketplaceProductCodeType",
      "isCritical": true,
      "isEnd": false,
      "onCancel": "step:unstageCreateHelperInstanceAutomation",
      "onFailure": "step:unstageCreateHelperInstanceAutomation",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeImages",
        "ImageIds": [
          "{{ createBaselineVolume.BaselineAmiId }}"
        ]
      },
      "outputs": [
        {
          "Name": "MarketplaceProductCodeType",
          "Selector": "$.Images[0].ProductCodes[0].ProductCodeType",
          "Type": "String"
        }
      ]
    },
    {
      "name": "branchOnMarketplaceProductCodeType",
      "action": "aws:branch",
      "inputs": {
        "Choices": [
          {
            "NextStep": "stopHelperInstance",
            "Variable": "{{ describeImage.MarketplaceProductCodeType }}",
            "StringEquals": "marketplace"
          }
        ],
        "Default": "attachInstanceRootVolumeToLinuxEC2HelperInstance"
      }
    },
    {
      "description": "Stop the Helper instance before attaching the volume if it has Markeplace product code associated.",
      "name": "stopHelperInstance",
      "action": "aws:changeInstanceState",
      "nextStep": "attachInstanceRootVolumeToLinuxEC2HelperInstance",
      "isCritical": false,
      "isEnd": false,
      "onCancel": "step:unstageCreateHelperInstanceAutomation",
      "onFailure": "step:forceStopInstance",
      "inputs": {
        "InstanceIds": [
          "{{ describeStackOutput.HelperInstanceId }}"
        ],
        "CheckStateOnly": false,
        "DesiredState": "stopped"
      }
    },
    {
      "description": "Forces stop the Helper instance.",
      "name": "forceStopInstance",
      "action": "aws:changeInstanceState",
      "nextStep": "attachInstanceRootVolumeToLinuxEC2HelperInstance",
      "isCritical": true,
      "isEnd": false,
      "onCancel": "step:unstageCreateHelperInstanceAutomation",
      "onFailure": "step:unstageCreateHelperInstanceAutomation",
      "inputs": {
        "InstanceIds": [
          "{{ describeStackOutput.HelperInstanceId }}"
        ],
        "CheckStateOnly": false,
        "DesiredState": "stopped",
        "Force": true
      }
    },
    {
      "description": "Attaches the EBS baseline root volume back to Linux EC2 Helper instance as /dev/sdf.",
      "name": "attachInstanceRootVolumeToLinuxEC2HelperInstance",
      "action": "aws:executeAwsApi",
      "nextStep": "waitForInstanceRootVolumeToBeAttachedToLinuxEC2HelperInstance",
      "isCritical": true,
      "isEnd": false,
      "onCancel": "step:unstageCreateHelperInstanceAutomation",
      "onFailure": "step:unstageCreateHelperInstanceAutomation",
      "inputs": {
        "Service": "ec2",
        "Api": "AttachVolume",
        "Device": "/dev/sdf",
        "InstanceId": "{{ describeStackOutput.HelperInstanceId }}",
        "VolumeId": "{{ createBaselineVolume.BaselineVolumeId }}"
      }
    },
    {
      "description": "Waits for the EBS root volume status is in-use.",
      "name": "waitForInstanceRootVolumeToBeAttachedToLinuxEC2HelperInstance",
      "action": "aws:waitForAwsResourceProperty",
      "nextStep": "startLinuxHelperInstance",
      "isCritical": true,
      "isEnd": false,
      "onCancel": "step:unstageCreateHelperInstanceAutomation",
      "onFailure": "step:unstageCreateHelperInstanceAutomation",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeVolumes",
        "VolumeIds": [
          "{{ createBaselineVolume.BaselineVolumeId }}"
        ],
        "PropertySelector": "$.Volumes[0].State",
        "DesiredValues": [
          "in-use"
        ]
      }
    },
    {
      "description": "Start or make sure the Helper instance is running after attaching the volume.",
      "name": "startLinuxHelperInstance",
      "action": "aws:changeInstanceState",
      "nextStep": "waitForLinuxHelperInstanceStatusChecks",
      "isCritical": true,
      "isEnd": false,
      "onCancel": "step:unstageCreateHelperInstanceAutomation",
      "onFailure": "step:unstageCreateHelperInstanceAutomation",
      "inputs": {
        "InstanceIds": [
          "{{ describeStackOutput.HelperInstanceId }}"
        ],
        "CheckStateOnly": false,
        "DesiredState": "running"
      }
    },
    {
      "description": "Make sure the Linux Helper EC2 instance is passing the Instance Reachability check",
      "name": "waitForLinuxHelperInstanceStatusChecks",
      "action": "aws:waitForAwsResourceProperty",
      "timeoutSeconds": 1200,
      "nextStep": "replicatePartitionAndRsync",
      "isCritical": "true",
      "isEnd": false,
      "onCancel": "step:unstageCreateHelperInstanceAutomation",
      "onFailure": "step:unstageCreateHelperInstanceAutomation",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeInstanceStatus",
        "InstanceIds": [
          "{{ describeStackOutput.HelperInstanceId }}"
        ],
        "PropertySelector": "$.InstanceStatuses[0].InstanceStatus.Status",
        "DesiredValues": [
          "ok"
        ]
      }
    },
    {
      "description": "Execute the script to replicate the partitioning, the FS layout and sync the content of the FS",
      "name": "replicatePartitionAndRsync",
      "action": "aws:runCommand",
      "nextStep": "createSnapshotAfterSynch",
      "isCritical": "true",
      "isEnd": false,
      "onCancel": "step:unstageCreateHelperInstanceAutomation",
      "onFailure": "step:unstageCreateHelperInstanceAutomation",
      "inputs": {
        "DocumentName": "AWS-RunShellScript",
        "InstanceIds": [
          "{{InstanceId}}"
        ],
        "Parameters": {
          "commands": [
            "#!/bin/bash",
            "",
            "# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.",
            "# SPDX-License-Identifier: MIT-0",
            "",
            "error_trap()",
            "{",
            "    if test -n \"$1\" ; then",
            "        printf \"%s\\\\n\" \"[ERROR] $1\"",
            "    fi",
            "",
            "    printf \"%.s=\" $(seq 1 80)",
            "    printf \"\\\\nThe BackupOutpostsServerInstance Script execution did not complete successfully.\\\\n\"",
            "",
            "    cleanup",
            "",
            "    exit 1",
            "}",
            "cleanup()",
            "{",
            "        # remove the temporary path and its content",
            "        rm -fr ${SCRIPT_PATH}",
            "}",
            "check_exclusions_for_partition()",
            "{",
            "       # function to check if the VALUE matches at least one of the regex in EXCLUSIONS_ARRAY.",
            "       local VALUE=\"$1\"",
            "       shift",
            "       local EXCLUSION_ARRAY=(\"$@\")",
            "       for EXCLUSION in \"${EXCLUSION_ARRAY[@]}\"",
            "       do",
            "               if [[ \"${VALUE}\" == \"${EXCLUSION}\" ]]; then",
            "                       return 0",
            "               fi",
            "       done",
            "       return 1",
            "}",
            "rsync_no_vanished()",
            "{",
            "        # function to prevent rsync resulting in error when files are deleted on the source while performing the backup. This is a normal scenarion in a Live System",
            "        # Taken from rsync doc:  https://git.samba.org/?p=rsync.git;a=blob_plain;f=support/rsync-no-vanished;hb=HEAD",
            "",
            "        REAL_RSYNC=/usr/bin/rsync",
            "        IGNOREEXIT=24",
            "        IGNOREOUT='^(file has vanished: |rsync warning: some files vanished before they could be transferred)'",
            "",
            "        set -o pipefail",
            "",
            "        # This filters stderr without merging it with stdout:",
            "        { $REAL_RSYNC \"${@}\" 2>&1 1>&3 3>&- | grep -E -v \"$IGNOREOUT\"; ret=${PIPESTATUS[0]}; } 3>&1 1>&2",
            "",
            "        if [[ $ret == $IGNOREEXIT ]]; then",
            "                ret=0",
            "        fi",
            "",
            "        return $ret",
            "}",
            "",
            "unalias -a",
            "shopt -s expand_aliases",
            "",
            "UNIQUE_ID='{{ UniqueId }}'",
            "AWS_REGION='{{ global:REGION }}'",
            "HELPER_INSTANCE_PRIVATE_KEY_ID='{{ describeStackOutput.HelperInstanceKeyID }}'",
            "HELPER_INSTANCE_PRIVATE_IP='{{ describeStackOutput.HelperInstancePrivateIp }}'",
            "BASELINE_VOLUME_ID='{{ createBaselineVolume.BaselineVolumeId }}'",
            "EXCLUSIONS_PARAMETER='{{ Exclusions }}'",
            "BWLIMIT_PARAMETER='{{ MaxThroughput }}'",
            "",
            "SCRIPT_PATH=/var/lib/amazon/ssm/BACKUP_AUTOMATION_${UNIQUE_ID}",
            "HELPER_INSTANCE_PRIVATE_KEY_NAME=SSMAutomation-BackupOutpostsServerInstance-{{UniqueId}}-helperInstanceKey.pem",
            "",
            "#Create Working Directory",
            "mkdir ${SCRIPT_PATH} || error_trap \"Failed to create the local path ${SCRIPT_PATH} to store the temporary script data\"",
            "",
            "# fetch the private key from the ssm parameters and store it in the .pem file",
            "aws ssm get-parameter --region ${AWS_REGION} --name /ec2/keypair/${HELPER_INSTANCE_PRIVATE_KEY_ID} --with-decryption --query Parameter.Value --output text > \"${SCRIPT_PATH}/${HELPER_INSTANCE_PRIVATE_KEY_NAME}\" || error_trap \"Failed to get the private key content and save it to a .pem file\"",
            "chmod 400 \"${SCRIPT_PATH}/${HELPER_INSTANCE_PRIVATE_KEY_NAME}\"",
            "",
            "#Define the array of exclusions based on the user input and the Source Path",
            "read -r -a EXCLUDES_ARRAY <<< \"${EXCLUSIONS_PARAMETER}\"",
            "",
            "#Define the ssh user to access the Helper instance. The Helper instance is the latest AL2023 AMI, so the user is ec2-user",
            "SSH_USER=\"ec2-user\"",
            "alias ssh_helper_instance=\"ssh -o StrictHostKeyChecking=no -i \"${SCRIPT_PATH}/${HELPER_INSTANCE_PRIVATE_KEY_NAME}\" ${SSH_USER}@${HELPER_INSTANCE_PRIVATE_IP}\"",
            "",
            "#Define the command alias to perform scp to the Helper instance",
            "alias scp_helper_instance=\"scp -o StrictHostKeyChecking=no -i \"${SCRIPT_PATH}/${HELPER_INSTANCE_PRIVATE_KEY_NAME}\"\"",
            "",
            "#Create Working Directory in the Helper instance",
            "ssh_helper_instance \"sudo mkdir ${SCRIPT_PATH}\"",
            "ssh_helper_instance \"sudo chown ec2-user ${SCRIPT_PATH}\"",
            "",
            "#identify root device name and root device path",
            "ROOT_DEVICE_NAME=$(lsblk -no PKNAME $(findmnt -n -o SOURCE /))",
            "ROOT_DEVICE_ABSOLUTE_PATH=\"/dev/${ROOT_DEVICE_NAME}\"",
            "",
            "echo \"[INFO] Identified root device: ${ROOT_DEVICE_ABSOLUTE_PATH}\"",
            "",
            "#Backup the blocks storing the partition table data\"",
            "echo \"[INFO] backing up the partition table of \"${ROOT_DEVICE_ABSOLUTE_PATH}\" of the source instance\"",
            "echo 'abort' | sfdisk -b --no-reread --backup-file \"${SCRIPT_PATH}/sfdisk\" ${ROOT_DEVICE_ABSOLUTE_PATH} > /dev/null 2>&1",
            "",
            "#Copy the data to the Helper instance",
            "echo \"[INFO] copying the partition table backup to the Helper instance\"",
            "scp_helper_instance ${SCRIPT_PATH}/sfdisk-${ROOT_DEVICE_NAME}* ${SSH_USER}@${HELPER_INSTANCE_PRIVATE_IP}:${SCRIPT_PATH} || error_trap \"Failed to copy the partition table backup from the source instance to the Helper instance\"",
            "",
            "#Retrieve the device path corresponding to the restored volume in the helper instance",
            "ROOT_DEVICE_DISK_ID=$(sudo fdisk -l ${ROOT_DEVICE_ABSOLUTE_PATH} | awk '/Disk identifier/ {print $3}' ) || error_trap \"Failed to determine the Root device ID of the source instance running on Outposts\"",
            "VOLUME_ID_DEV_DISK=$(echo ${BASELINE_VOLUME_ID} | tr -d '-')",
            "TARGET_RESTORE_DEVICE_NAME=$(ssh_helper_instance \"sudo basename \\$(readlink /dev/disk/by-id/nvme-Amazon_Elastic_Block_Store_${VOLUME_ID_DEV_DISK})\") || error_trap \"Failed to determine the device name of the target DEVICE (baseline volume)\"",
            "TARGET_RESTORE_DEVICE_ABSOLUTE_PATH=\"/dev/${TARGET_RESTORE_DEVICE_NAME}\"",
            "",
            "echo \"[INFO] restoring the partition table backup to the volume \"${TARGET_RESTORE_DEVICE_ABSOLUTE_PATH}\" attached to the Helper instance\"",
            "for file_bak in ${SCRIPT_PATH}/sfdisk-${ROOT_DEVICE_NAME}-0x0*; do",
            "        HEXADECIMAL_CODE=$(echo ${file_bak} | grep -o -E '0x[[:xdigit:]]+')",
            "        ssh_helper_instance \"sudo dd if=${file_bak} of=${TARGET_RESTORE_DEVICE_ABSOLUTE_PATH} seek=$((${HEXADECIMAL_CODE})) bs=1 conv=notrunc\" || error_trap \"Failed to restore the partition on the Restored volume in the Helper instance\"",
            "done",
            "",
            "#Retrieve the list of partition names and their PARTUUID from the source device (instance store root volume)",
            "SOURCE_PARTITIONS_LIST_PARTUUID=$(lsblk -nl -o NAME,TYPE,PARTUUID -e 7,11 \"${ROOT_DEVICE_ABSOLUTE_PATH}\" | awk '$2 == \"part\" {print $3 }') || error_trap \"Failed to retrieve the lists of partitions PARTUUID on the Outposts server instance\"",
            "",
            "# iterate over the source partitions and perform the following checks and actions on each partition. Those checks and actions will be executed on the supported FS type only (xfs, ext4, vfat)",
            "# 1) Check if the source and target partition are formatted with the same FS type. If different, format the target partition with the same FS of the source",
            "# 2) Perform a FS check on the target FS. If it fails, format the target FS.",
            "# 3) Check if the FS of the source and target partition have same UUID. If different, align the target FS with the same UUID of the source",
            "# 4) Mount the target FS and check if the FS of the source and target partition have same size. Resize the target if different",
            "# 5) Rsync the content of FS between the source and target",
            "",
            "for source_partuuid in ${SOURCE_PARTITIONS_LIST_PARTUUID}; do",
            "        SOURCE_PARTITION_FULL_PATH=$(blkid -t PARTUUID=$source_partuuid -o device) || error_trap \"Failed to retrieve the source partition name from the PARTUUID\"",
            "        echo \"=================\"",
            "        echo \"[INFO] Checking partition ${SOURCE_PARTITION_FULL_PATH} on the Outposts Server instance\"",
            "",
            "        #Retrieve the corresponding target partition using the PARTUUID (replicated from the partition table backup and restore)",
            "        TARGET_PARTITION_FULL_PATH=$(ssh_helper_instance \"sudo blkid --match-token PARTUUID=$source_partuuid -o device \"${TARGET_RESTORE_DEVICE_ABSOLUTE_PATH}\"*\") || error_trap \"Failed to retrieve the target partition name from the PARTUUID\"",
            "        echo \"[INFO] Identified corresponding partition ${TARGET_PARTITION_FULL_PATH} on the Helper instance\"",
            "",
            "        # Check the FS of the source and target partition",
            "        SOURCE_FS=$(lsblk -no FSTYPE ${SOURCE_PARTITION_FULL_PATH}) || error_trap \"Failed to retrieve the Source FS type\"",
            "        echo \"[INFO] source FS type is ${SOURCE_FS}\"",
            "        TARGET_FS=$(ssh_helper_instance \"sudo lsblk -no FSTYPE ${TARGET_PARTITION_FULL_PATH}\") || error_trap \"Failed to retrieve the target FS type\"",
            "        echo \"[INFO] target FS type is ${TARGET_FS}\"",
            "",
            "        echo \"[INFO] checking if the partition ${SOURCE_PARTITION_FULL_PATH} is present in the Exclusions parameter. If excluded, skip to the next partition\"",
            "        check_exclusions_for_partition \"${SOURCE_PARTITION_FULL_PATH}\" \"${EXCLUDES_ARRAY[@]}\"",
            "        value_excluded=\"$?\"",
            "        if [[ \"${value_excluded}\" -eq 0 ]]; then",
            "               echo \"[INFO] partition \"${SOURCE_PARTITION_FULL_PATH}\" excluded, no FS operations and data transfer will be performed. Skipping to the next partition\"",
            "               continue",
            "        else",
            "               echo \"[INFO] partition ${SOURCE_PARTITION_FULL_PATH} not excluded. Proceeding with the next steps\"",
            "        fi",
            "",
            "        case \"${SOURCE_FS}\" in",
            "             \"\")",
            "                     if [ -n \"${TARGET_FS}\" ]; then",
            "                             echo \"[INFO] partition with no FS on the source but with FS on the corresponding target partition, erasing the FS on target\"",
            "                             ssh_helper_instance \"sudo wipefs --all ${TARGET_PARTITION_FULL_PATH}\" || error_trap \"Failed to wipe fs on the target partition\"",
            "                     else",
            "                             echo \"[INFO] partition with no FS on both the source and the target, moving to the next step\"",
            "                     fi",
            "                     ;;",
            "             ext4|xfs|vfat)",
            "                     if [ \"${SOURCE_FS}\" != \"${TARGET_FS}\" ]; then",
            "                             echo \"[INFO] wiping the ${TARGET_FS} on ${TARGET_PARTITION_FULL_PATH}\"",
            "                             ssh_helper_instance \"sudo wipefs --all ${TARGET_PARTITION_FULL_PATH}\" || error_trap \"Failed to wipe the ${TARGET_FS} on ${TARGET_PARTITION_FULL_PATH}\"",
            "                             echo \"[INFO] Formatting ${TARGET_PARTITION_FULL_PATH} with ${SOURCE_FS}\"",
            "                             ssh_helper_instance \"sudo mkfs.${SOURCE_FS} ${TARGET_PARTITION_FULL_PATH}\" || error_trap \"Failed to format the partition ${TARGET_PARTITION_FULL_PATH} to ${SOURCE_FS}\"",
            "                     else",
            "                             echo \"[INFO] The Source and Target FS type match, nothing to do. Moving to the next step\"",
            "                     fi",
            "",
            "                     # Perform a FS check on the target FS. If it fails, format the target FS.",
            "                     echo \"[INFO] performing a FS Check on the target ${TARGET_PARTITION_FULL_PATH}\"",
            "                     case \"${SOURCE_FS}\" in",
            "                             ext4)",
            "                                     ssh_helper_instance \"sudo e2fsck -fy ${TARGET_PARTITION_FULL_PATH}\"",
            "                                     ;;",
            "                             xfs)",
            "                                     ssh_helper_instance \"sudo xfs_repair ${TARGET_PARTITION_FULL_PATH}\"",
            "                                     ;;",
            "                             vfat)",
            "                                     ssh_helper_instance \"sudo fsck.fat -a ${TARGET_PARTITION_FULL_PATH}\"",
            "                                     ;;",
            "                             *)",
            "                                     error_trap \"Unsupported file system: ${SOURCE_FS}, stopping the execution. If you want to skip this partition and perform the backup operations on the other ones, you can add ${SOURCE_PARTITION_FULL_PATH} to the Exclusions\"",
            "                     esac",
            "                     if [ $? -ne 0 ]; then",
            "                             echo \"[INFO] File System check failed. Wiping and Formatting the target FS\"",
            "                             ssh_helper_instance \"sudo wipefs --all ${TARGET_PARTITION_FULL_PATH}\" || error_trap \"Failed to wipe the ${TARGET_FS} on ${TARGET_PARTITION_FULL_PATH}\"",
            "                             ssh_helper_instance \"sudo mkfs.${SOURCE_FS} ${TARGET_PARTITION_FULL_PATH}\" || error_trap \"Failed to format the partition ${TARGET_PARTITION_FULL_PATH} to ${SOURCE_FS}\"",
            "                     else",
            "                             echo \"[INFO] File System Check on the target was successful. Moving to the next step\"",
            "                     fi",
            "",
            "                     # Get the UUID and LABEL of the FS of the source and target partition",
            "                     SOURCE_UUID=$(blkid -s UUID -o value ${SOURCE_PARTITION_FULL_PATH}) || error_trap \"Failed to retrieve the UUID of the source FS\"",
            "                     TARGET_UUID=$(ssh_helper_instance \"sudo blkid -s UUID -o value ${TARGET_PARTITION_FULL_PATH}\") || error_trap \"Failed to retrieve the UUID of the target FS\"",
            "                     SOURCE_LABEL=$(blkid -s LABEL -o value ${SOURCE_PARTITION_FULL_PATH}) || error_trap \"Failed to retrieve the LABEL of the source FS\"",
            "                     TARGET_LABEL=$(ssh_helper_instance \"sudo blkid -s LABEL -o value ${TARGET_PARTITION_FULL_PATH}\") || error_trap \"Failed to retrieve the LABEL of the target FS\"",
            "                     # Check and label the target file system with the same UUID as the source file system",
            "                     if [ \"${SOURCE_UUID}\" != \"${TARGET_UUID}\" ]; then",
            "                             echo \"[INFO] setting the UUID of the FS ${SOURCE_FS} on ${TARGET_PARTITION_FULL_PATH} to ${SOURCE_UUID}\"",
            "                             case \"${SOURCE_FS}\" in",
            "                                     ext4)",
            "                                             ssh_helper_instance \"sudo tune2fs ${TARGET_PARTITION_FULL_PATH} -U ${SOURCE_UUID}\" || error_trap \"Failed to set the UUID ${SOURCE_UUID} on the target FS\"",
            "                                             ;;",
            "                                     xfs)",
            "                                             ssh_helper_instance \"sudo xfs_admin -U ${SOURCE_UUID} ${TARGET_PARTITION_FULL_PATH}\" || error_trap \"Failed to set the UUID ${SOURCE_UUID} on the target FS\"",
            "                                             ;;",
            "                                     vfat)",
            "                                             ssh_helper_instance \"sudo mkfs.vfat -i \"${SOURCE_UUID//-}\" ${TARGET_PARTITION_FULL_PATH}\" || error_trap \"Failed to set the UUID ${SOURCE_UUID} on the target FS\"",
            "                                             ;;",
            "                                     *)",
            "                                             error_trap \"Unsupported file system: ${SOURCE_FS}, stopping the execution. If you want to skip this partition and perform the backup operations on the other ones, you can add ${SOURCE_PARTITION_FULL_PATH} to the Exclusions\"",
            "                             esac",
            "                     else",
            "                             echo \"[INFO] The Source and Target FS UUID match, nothing to do. Moving to the next step\"",
            "                     fi",
            "",
            "                     # Check and label the target file system with the same LABEL as the source file system",
            "                     if [ -n \"${SOURCE_LABEL}\" ]; then",
            "                             if [ \"${SOURCE_LABEL}\" != \"${TARGET_LABEL}\" ]; then",
            "                                     echo \"[INFO] Labeling ${TARGET_PARTITION_FULL_PATH} with ${SOURCE_LABEL}\"",
            "                                     case \"${SOURCE_FS}\" in",
            "                                             ext4)",
            "                                                     ssh_helper_instance \"sudo e2label ${TARGET_PARTITION_FULL_PATH} ${SOURCE_LABEL}\" || error_trap \"Failed to label the target FS\"",
            "                                                     ;;",
            "                                             xfs)",
            "                                                     ssh_helper_instance \"sudo xfs_admin -L ${SOURCE_LABEL} ${TARGET_PARTITION_FULL_PATH}\" || error_trap \"Failed to label the target FS\"",
            "                                                     ;;",
            "                                             vfat)",
            "                                                     ssh_helper_instance \"sudo fatlabel ${TARGET_PARTITION_FULL_PATH} ${SOURCE_LABEL}\" || error_trap \"Failed to label the target FS\"",
            "                                                     ;;",
            "                                             *)",
            "                                                     error_trap \"Unsupported file system: ${SOURCE_FS}, stopping the execution. If you want to skip this partition and perform the backup operations on the other ones, you can add ${SOURCE_PARTITION_FULL_PATH} to the Exclusions\"",
            "                                     esac",
            "                             else",
            "                                     echo \"[INFO] The Source and Target FS LABEL match, nothing to do. Moving to the next step\"",
            "                             fi",
            "                     else",
            "                             echo \"[INFO] No LABEL on the source FS. Moving to the next step\"",
            "                     fi",
            "                     #Get the source FS mountpoint for the partition and retrieve the FS size",
            "                     SOURCE_FS_MOUNTPOINT=$(findmnt -o TARGET \"${SOURCE_PARTITION_FULL_PATH}\" | sed \"1 d\") || error_trap \"Failed to get source FS Mountpoint\"",
            "                     SOURCE_FS_SIZE=$(df -k \"${SOURCE_FS_MOUNTPOINT}\" | awk 'NR==2 {print $2}') ||  error_trap \"Failed to get source FS size\"",
            "",
            "                     if [ -n \"${SOURCE_FS_SIZE}\" ]; then",
            "                             #Mount the target file system",
            "                             BASE_MOUNT=\"/mnt\"",
            "                             MOUNT_DIR=\"${BASE_MOUNT}${SOURCE_FS_MOUNTPOINT}\"",
            "                             ssh_helper_instance \"sudo mkdir -p ${MOUNT_DIR}\" || error_trap \"Failed to create the mount point directory ${MOUNT_DIR} on the helper instance\"",
            "                             echo \"[INFO] Mounting ${TARGET_PARTITION_FULL_PATH} to ${MOUNT_DIR}\"",
            "                             if [ \"${SOURCE_FS}\" == \"xfs\" ]; then",
            "                                     ssh_helper_instance \"sudo mount -o nouuid ${TARGET_PARTITION_FULL_PATH} ${MOUNT_DIR}\" ||  error_trap \"Failed to mount the target FS on ${TARGET_PARTITION_FULL_PATH}\"",
            "                             else",
            "                                     ssh_helper_instance \"sudo mount ${TARGET_PARTITION_FULL_PATH} ${MOUNT_DIR}\" ||  error_trap \"Failed to mount the target FS on ${TARGET_PARTITION_FULL_PATH}\"",
            "                             fi",
            "",
            "                             #Check and resize the target file system to match the source file system size",
            "                             echo \"[INFO] Size (1K) of the Source FS on ${SOURCE_PARTITION_FULL_PATH}: ${SOURCE_FS_SIZE}\"",
            "                             TARGET_FS_SIZE=$(ssh_helper_instance \"sudo df -k ${MOUNT_DIR} | awk 'NR==2 {print \\$2}'\") || error_trap \"Failed to get target FS size\"",
            "                             echo \"[INFO] Size (1K) of the Target FS on ${TARGET_PARTITION_FULL_PATH}: ${TARGET_FS_SIZE}\"",
            "",
            "                             if [ \"${SOURCE_FS_SIZE}\" != \"${TARGET_FS_SIZE}\" ]; then",
            "                                     echo \"[INFO] Resizing ${TARGET_PARTITION_FULL_PATH} to match the source file system size\"",
            "                                     case \"${SOURCE_FS}\" in",
            "                                             ext4)",
            "                                                     SOURCE_EXT_FS_BLOCKS=$(dumpe2fs -h ${SOURCE_PARTITION_FULL_PATH} | awk -F: '/Block count/{count=$2} END{print count}' | tr -d \" \\t\\r\") || error_trap \"Failed to get the number of blocks of the source ext FS\"",
            "                                                     ssh_helper_instance \"sudo resize2fs ${TARGET_PARTITION_FULL_PATH} ${SOURCE_EXT_FS_BLOCKS}\" || error_trap \"Failed to resize the target FS\"",
            "                                                     ;;",
            "                                             xfs)",
            "                                                     SOURCE_XFS_FS_BLOCKS=$(xfs_info ${SOURCE_FS_MOUNTPOINT} | grep -e \"^data\" | grep -oP 'blocks=\\K[^ ,]+' | cut -d \"=\" -f2) || error_trap \"Failed to get the number of blocks of the source xfs FS\"",
            "                                                     ssh_helper_instance \"sudo xfs_growfs ${MOUNT_DIR} -D ${SOURCE_XFS_FS_BLOCKS}\" || error_trap \"Failed to resize the target FS\"",
            "                                                     ;;",
            "                                             *)",
            "                                                     error_trap \"Unsupported file system: ${SOURCE_FS}, stopping the execution. If you want to skip this partition and perform the backup operations on the other ones, you can add ${SOURCE_PARTITION_FULL_PATH} to the Exclusions\"",
            "                                     esac",
            "                             else",
            "                                     echo \"[INFO] The Source and Target FS size match, nothing to do. Moving to the next step\"",
            "                             fi",
            "                             #rsync the content between the source and the target FS",
            "                             RSYNC_OPTIONS=(--stats --delete -avHAxXSPRz)",
            "                             if [ \"${SOURCE_FS}\" == \"vfat\" ]; then",
            "                                     RSYNC_OPTIONS+=( --filter='-x security.selinux')",
            "                             fi",
            "                             echo \"[INFO] executing rsync of the content between the source and target FS\"",
            "                             rsync_no_vanished -e \"ssh -o StrictHostKeyChecking=no -i \"${SCRIPT_PATH}/${HELPER_INSTANCE_PRIVATE_KEY_NAME}\"\" --rsync-path=\"sudo rsync\" \"${EXCLUDES_ARRAY[@]/#/--exclude=}\" --exclude=\"${SCRIPT_PATH}\" --bwlimit=${BWLIMIT_PARAMETER} \"${RSYNC_OPTIONS[@]}\" \"${SOURCE_FS_MOUNTPOINT}/\" ${SSH_USER}@${HELPER_INSTANCE_PRIVATE_IP}:${BASE_MOUNT} || error_trap \"Failed to rsync the content between the Source and target FS\"",
            "",
            "                             echo \"[INFO] rsync completed!\"",
            "",
            "                             echo \"[INFO] unmounting ${TARGET_PARTITION_FULL_PATH}\"",
            "                             #unmounting the target file system",
            "                             ssh_helper_instance \"sudo umount ${TARGET_PARTITION_FULL_PATH}\" ||  error_trap \"Failed to unmount the target FS on ${TARGET_PARTITION_FULL_PATH}\"",
            "",
            "                     else",
            "                             echo \"[INFO] The FS is not mounted on the Source. Cannot replicate the data. Moving to the next step\"",
            "                     fi",
            "                     ;;",
            "             *LVM2_member*)",
            "                     error_trap \"The partition \"${SOURCE_PARTITION_FULL_PATH}\" on Outposts Server instance is managed by LVM. LVM is not Supported on this Automation. We suggest using the native snapshotting capabilities provided by LVM to backup your data and save the snapshots on durable storage (e.g. S3, EBS). you want to skip this partition and perform the backup operations on the other ones, you can add ${SOURCE_PARTITION_FULL_PATH} to the Exclusions\"",
            "                     ;;",
            "             *)",
            "                     error_trap \"Unsupported file system: ${SOURCE_FS}, stopping the execution. If you want to skip this partition and perform the backup operations on the other ones, you can add ${SOURCE_PARTITION_FULL_PATH} to the Exclusions\"",
            "        esac",
            "",
            "done",
            "echo \"=================\"",
            "echo \"[INFO] Execution finished successfully\"",
            "cleanup || error_trap \"Failed to cleanup the temporary script data\""
          ],
          "executionTimeout": "86400"
        }
      }
    },
    {
      "description": "Create a snapshot of the EBS volume attached to the target instance where the data was synched",
      "name": "createSnapshotAfterSynch",
      "action": "aws:executeAwsApi",
      "nextStep": "stopHelperInstanceAfterSnapshot",
      "isCritical": "true",
      "isEnd": false,
      "onCancel": "step:unstageCreateHelperInstanceAutomation",
      "onFailure": "step:unstageCreateHelperInstanceAutomation",
      "inputs": {
        "Service": "ec2",
        "Api": "CreateSnapshot",
        "VolumeId": "{{ createBaselineVolume.BaselineVolumeId }}",
        "Description": "BackupOutpostsServerInstance-{{ InstanceId }}_{{UniqueId}}"
      },
      "outputs": [
        {
          "Name": "SnapshotId",
          "Selector": "$.SnapshotId",
          "Type": "String"
        }
      ]
    },
    {
      "description": "Stop the Helper instance after starting the snapshot creation and while waiting for its completion.",
      "name": "stopHelperInstanceAfterSnapshot",
      "action": "aws:changeInstanceState",
      "nextStep": "waitForSnapshotCompletion",
      "isCritical": false,
      "isEnd": false,
      "onCancel": "step:unstageCreateHelperInstanceAutomation",
      "onFailure": "step:forceStopInstanceAfterSnapshot",
      "inputs": {
        "InstanceIds": [
          "{{ describeStackOutput.HelperInstanceId }}"
        ],
        "CheckStateOnly": false,
        "DesiredState": "stopped"
      }
    },
    {
      "description": "Forces stop the Helper instance.",
      "name": "forceStopInstanceAfterSnapshot",
      "action": "aws:changeInstanceState",
      "nextStep": "waitForSnapshotCompletion",
      "isCritical": false,
      "isEnd": false,
      "inputs": {
        "InstanceIds": [
          "{{ describeStackOutput.HelperInstanceId }}"
        ],
        "CheckStateOnly": false,
        "DesiredState": "stopped",
        "Force": true
      }
    },
    {
      "description": "Wait for the completion of the EBS snapshot before creating an AMI from it.",
      "name": "waitForSnapshotCompletion",
      "action": "aws:waitForAwsResourceProperty",
      "nextStep": "createAMIFromSnapshot",
      "isCritical": true,
      "isEnd": false,
      "onCancel": "step:unstageCreateHelperInstanceAutomation",
      "onFailure": "step:unstageCreateHelperInstanceAutomation",
      "inputs": {
        "Service": "ec2",
        "Api": "DescribeSnapshots",
        "SnapshotIds": [
          "{{ createSnapshotAfterSynch.SnapshotId }}"
        ],
        "PropertySelector": "$.Snapshots[0].State",
        "DesiredValues": [
          "completed"
        ]
      }
    },
    {
      "description": "Create an AMI from the EBS snapshot created previously",
      "name": "createAMIFromSnapshot",
      "action": "aws:executeAwsApi",
      "nextStep": "unstageCreateHelperInstanceAutomation",
      "isCritical": "true",
      "isEnd": false,
      "onCancel": "step:unstageCreateHelperInstanceAutomation",
      "onFailure": "step:unstageCreateHelperInstanceAutomation",
      "inputs": {
        "Service": "ec2",
        "Api": "RegisterImage",
        "Name": "BackupOutpostsServerInstance-{{ InstanceId }}_{{UniqueId}}",
        "Architecture": "{{describeInstance.Architecture}}",
        "RootDeviceName": "{{describeInstance.RootDeviceName}}",
        "VirtualizationType": "{{describeInstance.VirtualizationType}}",
        "BlockDeviceMappings": [
          {
            "DeviceName": "{{describeInstance.RootDeviceName}}",
            "Ebs": {
              "SnapshotId": "{{ createSnapshotAfterSynch.SnapshotId }}"
            }
          }
        ]
      },
      "outputs": [
        {
          "Name": "ImageId",
          "Selector": "$.ImageId",
          "Type": "String"
        }
      ]
    },
    {
      "description": "Describes errors from the EC2 Helper Instance CloudFormation stack.",
      "name": "describeCloudFormationErrorFromStackEvents",
      "action": "aws:executeAwsApi",
      "maxAttempts": 3,
      "nextStep": "waitForCloudFormationStack",
      "isCritical": false,
      "isEnd": false,
      "onCancel": "step:unstageCreateHelperInstanceAutomation",
      "onFailure": "step:waitForCloudFormationStack",
      "inputs": {
        "Service": "cloudformation",
        "Api": "DescribeStackEvents",
        "StackName": "{{ stageCreateHelperInstanceAutomation.CloudFormationStackId }}"
      },
      "outputs": [
        {
          "Name": "Events",
          "Selector": "$.StackEvents..ResourceStatusReason",
          "Type": "StringList"
        }
      ]
    },
    {
      "description": "Waits until the AWS CloudFormation stack is in a terminal status before deleting it.",
      "name": "waitForCloudFormationStack",
      "action": "aws:waitForAwsResourceProperty",
      "maxAttempts": 3,
      "timeoutSeconds": 600,
      "nextStep": "unstageCreateHelperInstanceAutomation",
      "isCritical": false,
      "isEnd": false,
      "onCancel": "step:unstageCreateHelperInstanceAutomation",
      "onFailure": "step:unstageCreateHelperInstanceAutomation",
      "inputs": {
        "Service": "cloudformation",
        "Api": "DescribeStacks",
        "StackName": "{{ stageCreateHelperInstanceAutomation.CloudFormationStackId }}",
        "PropertySelector": "$.Stacks[0].StackStatus",
        "DesiredValues": [
          "UPDATE_COMPLETE",
          "CREATE_COMPLETE",
          "ROLLBACK_FAILED",
          "ROLLBACK_COMPLETE",
          "DELETE_COMPLETE",
          "CREATE_FAILED",
          "DELETE_FAILED",
          "UPDATE_ROLLBACK_FAILED",
          "UPDATE_ROLLBACK_COMPLETE"
        ]
      }
    },
    {
      "description": "Deletes the CreateHelperInstanceAutomation CloudFormation stack.",
      "name": "unstageCreateHelperInstanceAutomation",
      "action": "aws:deleteStack",
      "maxAttempts": 3,
      "nextStep": "cleanupBaselineInstanceRootVolume",
      "isCritical": true,
      "isEnd": false,
      "onCancel": "step:cleanupBaselineInstanceRootVolume",
      "onFailure": "step:cleanupBaselineInstanceRootVolume",
      "inputs": {
        "StackName": "{{ stageCreateHelperInstanceAutomation.CloudFormationStackId }}"
      }
    },
    {
      "description": "Delete the Baseline instance's EBS root volume.",
      "name": "cleanupBaselineInstanceRootVolume",
      "action": "aws:executeAwsApi",
      "isCritical": true,
      "isEnd": true,
      "inputs": {
        "Service": "ec2",
        "Api": "DeleteVolume",
        "VolumeId": "{{ createBaselineVolume.BaselineVolumeId }}"
      }
    }
  ],
  "outputs": [
    "createAMIFromSnapshot.ImageId"
  ]
}
